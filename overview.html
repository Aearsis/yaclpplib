<!DOCTYPE html>
<html>
	<head>
		<title>Yaclpplib</title>
		<meta charset="utf8"/>
	</head>
<body>

<p><strong>Yaclpplib</strong> is a library written in Java 8 for parsing arguments
    given during startup of your programs. The library is built upon Java reflection and annotations.
    The user of this library is meant to define a class implementing interface <code>Options</code>
    and annotate those class' fields and methods. The library will then parse the arguments and set values
    of annotated fields and call annotated methods.
</p>
<p>
    This page describes the architecture of the library and the functions of various packages and interfaces.
    For basic usage guide and a quick overview of provided classes and annotations, see README.
</p>
<h1>
    <a href="cz/cuni/mff/yaclpplib/annotation/package-summary.html">Annotations</a>
</h1>
<p>
    This library uses annotations,
    which users use to annotate their class members. These annotations are predefined
    and adding your own shouldn't be needed unless you need something similar to the <code>Range</code> annotation.
    Each annotation is processed in a different part of the library implementation,
    so we will go over them as we need them.
</p>
<h1>
    <a href="cz/cuni/mff/yaclpplib/OptionValue.html">OptionValue</a>
</h1>
<p>
    An <code>OptionValue</code> is abstracting the pair of an option and its argument.
    The classes implementing this interface are supposed to take a string (or two, if it's in "option value" format)
    and split it into "option" and "value".
    Currently, the library offers implementations for two different type of option formats.
</p>
<p>
    The first supported format is described by
    <a href="cz/cuni/mff/yaclpplib/implementation/ShortOptionValue.html"><code>ShortOptionValue</code></a>.
    It handles options, which start with
    a dash ("-") and a single letter or number. It supports two different type of values,
    either a value separated by a space, or without it. In other words, both "-pvalue" and "-p value" are supported.
</p>
<p>
    The second supported format is described by
    <a href="cz/cuni/mff/yaclpplib/implementation/LongOptionValue.html"><code>LongOptionValue</code></a>.
    It handles options starting with two
    dashes ("--") and at least one letter or number. The values of these options are separated by an equals sign ("=").
    Some examples of handled options are "--o", "--all", "--type=something", "--size=5".
</p>
<p>
    The instances of these classes are created by <code>InternalOptionValueFactory</code>.
    If you wish to support a new type, create a new class implementing <code>InternalOptionValue</code>
    interface and modify the <code>InternalOptionValueFactory#tryCreate()</code>method.
</p>
<h1>
    <a href="cz/cuni/mff/yaclpplib/driver/Driver.html">Drivers</a>
</h1>
<p>
    The parsing itself is handled by drivers, which are short classes implementing <code>Driver</code> interface.
    The main function is in the
    <a href="cz/cuni/mff/yaclpplib/driver/Driver.html#parse-cz.cuni.mff.yaclpplib.OptionValue-">
        <code>parse(OptionValue value)</code></a> method, which takes an OptionValue instance
    and tries to convert the value into desired type.
    We will shortly go over our drivers, since some of them handle multiple types at once. All of these drivers
    are found in the <code>yaclpplib.drivers</code> package.
</p>
<ul>
    <li><a href="cz/cuni/mff/yaclpplib/driver/BooleanDriver.html"><code>BooleanDriver</code></a> - parses all usual
        representations of truthy and falsy values into true or false</li>
    <li><a href="cz/cuni/mff/yaclpplib/driver/CharacterDriver.html"><code>CharacterDriver</code></a>
        - converts a String into char</li>
    <li><a href="cz/cuni/mff/yaclpplib/driver/GenericEnumDriver.html"><code>GenericEnumDriver</code></a>
        and <a href="cz/cuni/mff/yaclpplib/driver/GenericCaseInsensitiveEnumDriver.html"><code>GenericCaseInsensitiveEnumDriver</code></a>
        - convert a String constant into a matching enum value depending on CaseSensitive annotation</li>
    <li><a href="cz/cuni/mff/yaclpplib/driver/StringDriver.html"><code>StringDriver</code></a>
        - a special driver which can convert string into anything,
        that has a String constructor. This driver also works for all numeric types.</li>
    <li><a href="cz/cuni/mff/yaclpplib/driver/VoidDriver.html"><code>VoidDriver</code></a>
        - a special driver used for options, that never take value</li>
</ul>
<p>
    These drivers are provided by classes implementing
    <a href="cz/cuni/mff/yaclpplib/implementation/drivers/DriverLocator.html"><code>DriverLocator</code></a>
    interface. The purpose of
    a <code>DriverLocator</code> is to determine, whether it has a driver for a given Java <code>Class</code>
    and if so, provide a driver which can parse string into instances of those classes.
</p>
<p>
    Our library currently implements 4 driver locators. These and their interfaces are found in
    <code>yaclpplib.implementation.drivers</code> package.
</p>
<ul>
    <li><a href="cz/cuni/mff/yaclpplib/implementation/drivers/EnumDriverFactory.html"><code>EnumDriverFactory</code></a> - locator creating instances of enum drivers for a concrete enum class</li>
    <li><a href="cz/cuni/mff/yaclpplib/implementation/drivers/StringConstructableDriverFactory.html">
        <code>StringConstructableDriverFactory</code></a> - locator providing a driver instance for classes,
        that have a constructor taking a String</li>
    <li><a href="cz/cuni/mff/yaclpplib/implementation/drivers/HashDriverLocator.html"><code>HashDriverLocator</code></a>
        - which stores all miscellaneous drivers</li>
    <li><a href="cz/cuni/mff/yaclpplib/implementation/drivers/DriverCache.html"><code>DriverCache</code></a>
        - which abstracts all other locators and tries to use each of them</li>
</ul>
<p>
    The main argument parser implementation then checks, what type the parsed option has and asks a driver cache
    for a matching driver. If the driver is found, it uses it to parse the argument and create a value and if not,
    the argument is treated as a plain argument if possible, otherwise an exception is thrown.
</p>
<h1>
    <a href="cz/cuni/mff/yaclpplib/implementation/OptionHandler.html">OptionHandlers</a>
</h1>
<p>
    <code>OptionHandlers</code> are classes responsible for accessing and modifying annotated fields.
    All the relevant classes are in the <code>yaclpplib.implementation.options</code> package.
    These are the classes that set values of fields annotated with <code>Option</code> or call methods with the same
    annotations. The methods are described by <code>OptionHandler</code> interface and common implementation
    is provided by <code>MemberOptionHandler</code> abstract class.
</p>
<p>
    The two main implementations of <code>OptionHandler</code> are <code>FieldOptionHandler</code>,
    which is used when user annotates a class field and sets the field to the parsed value,
    and <code>MethodOptionHandler</code>, which calls an annotated method with the parsed value.
    These <code>OptionHandlers</code> are created by <code>ArgumentParser</code> itself in <code>addOptions()</code>
    method.
    If you wish to implement a handler for a different entity,
    you might need to create a new <code>OptionHandler</code>.
</p>
<p>
    The library also provides decorators, which are wrapper classes providing special functionality.
    These are needed to provide some of the required functions and are wrapped around <code>FieldOptionHandler</code>
    or <code>MethodOptionHandler</code>. If you are looking to implement a simple functionality or a quirk for some
    special case, creating a new decorator may solve your problem.
</p>
<p>
    <b>Warning: the order of wrapping decorators matters as some of them consume or change the value.</b>
</p>
<h1>
    <a href="cz/cuni/mff/yaclpplib/ArgumentParser.html">ArgumentParser</a>
</h1>
<p>
    Next few paragraphs will describe the function of argument parser itself,
    especially the library implementation, <code>ArgumentParserImpl</code>.
</p>
<p>
    Argument parser works in two stages. The first stage in configuration, which sets up the parser and creates
    required objects. One part of the configuration doesn't usually have to be altered by the library user.
    That includes initializing internal structures and more importantly, adding the driver locators.
    When the driver locators are added, users can call <code>addOptions()</code> method. This method analyses the given
    instance's class, finds all fields and methods annotated with <code>Option</code> and methods annotated with
    <code>AfterParse</code> annotation, creates handlers for them and creates a mapping from option to handler.
    If any of these steps fail, the library throws an <code>InvalidSetupError</code> as all of these are a result
    of mistakes in the code, not values found in runtime.
</p>
<p>
    The second stage is parsing itself. This is done by calling <code>parse()</code> method. This method can throw
    <code>RuntimeException</code>, which is done to allow user calling the library without surrounding the code
    with try-catch block, as some users may want to let the exception end the program.
</p>
<p>
    The <code>parse()</code> methods goes through the list of string tokens given in the argument (which should
    be command line arguments). For each token, it tries to create a valid <code>OptionValue</code>.
    If an <code>OptionValue</code> is created, an <code>OptionHandler</code> is looked up.
    If either of these fails, the token is considered a plain argument and the handler is called.
    Then, since the type is known by the handler, the driver locator is called and the driver used to parse the token.
    The parsed token is then given to the handler so it can set up the value.
</p>
<p>
    After the token list is processed, every field or method with <code>Mandatory</code> annotation is checked,
    whether it was really encountered. Then, every method annotated with <code>AfterParse</code> is called and
    all RuntimeExceptions are forwarded to user. This end the parsing.
</p>
<p>
    Most of the parts are separated into methods or even special classes
    (for example <a href="cz/cuni/mff/yaclpplib/implementation/MandatoryManager.html"><code>MandatoryManager</code></a>).
    Therefore should you want to change the behavior of parsing, you should be able to do so without
    large scale changes to the code.
</p>
</body>
</html>
